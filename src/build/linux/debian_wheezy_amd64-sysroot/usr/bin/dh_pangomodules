#!/usr/bin/perl -w

=head1 NAME

dh_pangomodules - create a Pango Module file for all Pango modules

=cut

use strict;
use Debian::Debhelper::Dh_Lib;
use Cwd;

=head1 SYNOPSIS

B<dh_pangomodules> [S<I<debhelper options>>] [S<I<directory or module>> ...]

=head1 DESCRIPTION

B<dh_pangomodules> is a debhelper program that handles correctly
generating Pango Module files with modules that it finds in the
Pango Modules Path, in directories you pass on the command line,
and on the command line.

This command scans the specified packages for Pango modules thanks to
pango-querymodules.  When any module is found, the generated
<package>.modules file is installed into the corresponding package and a
dependency on the Module API version of pango is added to
${misc:Depends}.

=head1 OPTIONS

=over 4

=item B<-k>

Do not generate any dependencies in ${misc:Depends}.

=cut

init();

# 'abs_path' from Cwd resolves symlinks, and we don't want that to happen
# (otherwise it's harder to remove the prefix of the generated output)
sub make_absolute_path {
    my $path = shift;
    if ($path =~ m#^/#) {
        return $path;
    }
    my $cwd = getcwd;
    return "$cwd/$path";
}

# pango-querymodules helper (generates a Pango Module File on its stdout with
# *.so passed on its command-line)
my $querymodules;
if ($ENV{PANGO_QUERYMODULES}) {
    $querymodules = $ENV{PANGO_QUERYMODULES};
} else {
    $querymodules = '/usr/bin/pango-querymodules';
}

# relative Pango Modules Path (separated by ":")
my $modules_path = 'usr/lib/x86_64-linux-gnu/pango/1.6.0/modules';

# relative directory to store the generated Pango Module File
my $module_files_d = 'usr/lib/x86_64-linux-gnu/pango/1.6.0/module-files.d';

# Pango Module API version virtual Provide
my $pango_modver_dep = 'pango1.0-multiarch-modver-1.6.0';

foreach my $package (@{$dh{DOPACKAGES}}) {
    my $tmp = tmpdir($package);
    my @modules = ();

    # locations to search for modules
    my @module_search_locations;

    # split the path
    foreach my $dir (split(/:/, $modules_path)) {
        push @module_search_locations, "$tmp/$dir"
    }

    # append the remaining command line arguments (either modules or
    # directories to scan for *.so modules)
    push @module_search_locations, @ARGV if @ARGV;

    foreach (@module_search_locations) {
        # it's necessary to make the path absolute to strip the build-time
        # prefix later on
        my $path = make_absolute_path($_);
        if (! -e $path) {
            verbose_print("skipping $path.");
            next;
        }
        if (-d $path) {
            # if path is a directory (or symlink to a directory), search for
            # *.so files or symlinks
            open(FIND,
              "find '$path' -name '*.so' \\( -type f -or -type l \\) |")
              or die "Can't run find: $!";
            while (<FIND>) {
                chomp;
                push @modules, $_;
            }
            close FIND;
        } elsif (-f $path or -l $path) {
            # if path is a file or symlink, simply add it to the list
            push @modules, $path;
        } else {
            error("$path has unknown file type.");
        }
    }

    if (0 == @modules) {
        warning("couldn't find any Pango Modules for package $package.");
        next;
    }

    # since there's at least one module, generate a dependency on the
    # Pango binary version
    if (! $dh{K_FLAG}) {
        addsubstvar($package, "misc:Depends", $pango_modver_dep);
    }

    my $do_query = join ' ', $querymodules, @modules;
    open(QUERY, "$do_query |")
        or die "Can't query modules: $!";

    my $module_file = "$tmp/$module_files_d/$package.modules";
    doit("rm", "-f", "$module_file");
    if (! -d "$tmp/$module_files_d") {
        doit("install", "-d", "$tmp/$module_files_d");
    }
    complex_doit("printf '%s\\n' '# automatically generated by dh_pangomodules, do not edit' >>$module_file");

    my $absolute_tmp = make_absolute_path($tmp);
    while (<QUERY>) {
        next if m/^#/;
        chomp;
        next if /^$/;
        # strip build-time prefix from output
        if (m#^\Q$absolute_tmp/\E#) {
            s#^\Q$absolute_tmp/\E#/#;
            complex_doit("printf '%s\\n' '$_' >>$module_file");
            next;
        }
        error("can't strip $absolute_tmp from output.");
    }

    doit("chmod", 644, "$module_file");
    doit("chown", "0:0", "$module_file");

    close QUERY;
}

=back

=head1 SEE ALSO

L<debhelper>

This program relies on Debhelper, but is shipped with the Pango
development files.

=head1 AUTHOR

Loic Minier <lool@dooz.org>

=cut
